<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
  </body>
  <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel"> 

    // setState
    const root = document.getElementById('root');
    function App() {
      // const data = React.useState(0);
      // console.log(data);
      /* React.useState()는 2개의 요소를 가지는 배열로 반환된다.
      (2) [undefined, ƒ] 
      - undefined : data
      - f : data를 바꿀 함수
      */

      const [counter, setCounter] = React.useState(0); // 초기값 0
    //  const counter = data[0]; 
    //  const setCounter = data[1];
    //  const [counter, setCounter] = data;  // 위 라인과 똑같은 결과. 배열의 각 항목을 한 번에 각 변수에 담는 방법

      const onClick = () => { // TODO 중괄호나 소괄호나 같음?
        // counter = counter + 1;
        // console.log(counter);
        //setCounter(counter + 1); // React는 원하는 부분만 수정할 수 있게 한다. 자동 리렌더링 (별도 함수호출 불필요)
        // 하지만, 위 식으로는 counter가 어딘가에서 업데이트 된다면 정확한 현재값을 가져올수 없다 
        setCounter((current) => current + 1); 
        // 리액트가 argument로 넘겨주는 current가 현재값이라는 것을 보장해 주기 떄문에 어딘가에서 업데이트 되도 이 함수의 리턴값이 현재값 + 1이 보장 되므로 이 방법을 사용하도록   
      };
      console.log('rendered'); // !!React에 의해 state가 변경되면 새로운 값을 가지고 리렌더링이 일어난다.!!
      console.log(counter);

      return (
        <div>
          <h3>Total clicks: {counter}</h3>
          <button onClick={onClick}>Click me</button>
      </div>
      );
    };
    ReactDOM.render(<App />, root); // 첫번째 렌더링 

  </script>
</html>